#' @name partial.corPSRs
#' @aliases partial.corPSRs
#' @title Partial correlation of probability scale residuals (PSRs)
#' @description Partial correlation of probability scale residuals (PSRs).
#' 
#' @usage partial.corPSRs(modX, modY, likelihood = "partial")
#' 
#' @param modX Survival model object (see examples below) for event X generated by either semi-parametric survival models using \code{coxph()} and \code{cph()}, or parametric survival models using \code{survreg()} with argument \code{dist} set to one of the following: weilbull, exponential, loglogistic, and lognormal.
#' @param modY Survival model object (see examples below) for event Y generated by either semi-parametric survival models using \code{coxph()} and \code{cph()}, or parametric survival models using \code{survreg()} with argument \code{dist} set to one of the following: weilbull, exponential, loglogistic, and lognormal.
#' @param likelihood This argument is only used when the Cox regression is fitted. When \code{likelihood = "partial"} then the confidence interval is computed using M-estimation with partial likelihood. When \code{likelihood = "full"} then the full likelihood is used.
#'
#' @return The point estimate and \code{0.95\%} confidence interval computed using M-estimation.
#' @details When fitting Cox proportional hazards model for continuous data (especially simulated data),
#' argument \code{timefix=TRUE} of \code{coxph()} or \code{cph()} needs to be set to \code{FALSE}
#' to avoid the 'detection' of spurious ties. When \code{likelihood = "partial"}
#' then the variance is estimated disregarding the variability of the baseline hazard.
#' When \code{likelihood = "full"} then the variability of the baseline hazard
#' is taken into account. However, using the full likelihood has two limitations.
#' First, the dimension of the M-estimation matrices may grow with the number
#' of observations, \code{n}, which means that the computational complexity
#' is quadratic,\code{n^2}. Second, the M-estimation matrices may
#' turn out to be singular, in which case, the function throws
#' a warning and uses the partial likelihood.
#' When using \code{cph()}, arguments \code{x} and \code{y} have to be set to \code{TRUE}.
#' 
#' In general, the value of the partial correlation cannot be greater than 1 or less than -1. However,
#' the confidence intervals are not altered to fit this restriction so the
#' user can see the magnitude of partial correlation variability.

#' @examples
#'    require(survival)
#'    X = c(0.5, 0.61, 0.6, 0.8, 0.78, 0.7, 0.9)
#'    Y = c(0.44, 0.15, 0.77, 0.88, 0.22, 0.99, .33)
#'    Z = c(-1.05, -0.43, -0.23, 1.19, 0.54, -0.09, -0.71)
#'    deltaX = c(1, 0, 1, 1, 0, 1, 0)
#'    deltaY = c(1, 0, 1, 0, 1, 1, 1)
#'  
#'    survObjX = Surv(X, deltaX)
#'    survObjY = Surv(Y, deltaY)
#'    modX = coxph(survObjX ~ Z, method = "breslow", timefix = FALSE)
#'    modY = coxph(survObjY ~ Z, method = "breslow", timefix = FALSE)
#'    partial.corPSRs(modX, modY)
#'
#'    modX = survreg(survObjX ~ Z, dist = "loglogistic")
#'    modY = survreg(survObjY ~ Z, dist = "loglogistic")
#'    partial.corPSRs(modX, modY)
#'    
#' @references Svetlana K Eden, Chun Li, and Bryan E Shepherd. Spearmanâ€™s rank correlation adjusting for covariates in bivariate survival data. In preparation, 2020.
#'
#' @author Svetlana K Eden, \email{svetlanaeden@gmail.com}
#'
#' @keywords probability scale residuals partial correlation
#' @importFrom stats cor pnorm qnorm dnorm plnorm model.matrix residuals
#' @export
###################################################################################
############################################### compute partial PSRs correlation
###################################################################################
partial.corPSRs = function(modX, modY, likelihood = "partial"){
  # res = c(est = psrWithStute$TS, strerr = sqrt(psrWithStute$varTS/length(X)), P = psrWithStute$pvalTS, lower.CI = psrWithStute$CI_TS[1], upper.CI = psrWithStute$CI_TS[2])
  # res
  #
  ### partial
  ##################################### identify the type of model
  modelX = as.character(modX$call)[1]
  modelY = as.character(modY$call)[1]
  if(modelX != modelY){
    stop("Arguments 'modX' and 'modY' should have the same type of model: parametric or Cox regression.")
  }
  
  ###### SURVREG
  if(modelX == "survreg"){
    scoreRes1 = mestimation.survregPSRs(object = modX, inverseA = TRUE)
    scoreRes2 = mestimation.survregPSRs(object = modY, inverseA = TRUE)
    corXY = corTS.survreg.modified(xresid = scoreRes1$presid, yresid = scoreRes2$presid,
                 xz.dl.dtheta = t(scoreRes1$dl.dtheta),
                 yz.dl.dtheta = t(scoreRes2$dl.dtheta),
                 xz.d2l.dtheta.dtheta = scoreRes1$d2l.dtheta.dtheta,
                 yz.d2l.dtheta.dtheta = scoreRes2$d2l.dtheta.dtheta,
                 dxresid.dthetax = scoreRes1$dpresid.dtheta,
                 dyresid.dthetay = scoreRes2$dpresid.dtheta, inverseA = TRUE)
  }
  
  ###### COX
  if(any(modelX %in% c("cph", "coxph"))){
    likelDict = c("partial" = "old", "full" = "full")
    if(is.na(likelDict[likelihood])){
      stop("Argument 'likelihood' can be set to either 'partial' or 'full'")
    }
    corXY = mestimation.coxph(object1 = modX, object2 = modY, method = likelDict[likelihood])
  }
  res = c(est = corXY$TS, strerr = sqrt(corXY$varTS/modX$n), P = corXY$pvalTS, lower.CI = corXY$CI_TS[1], upper.CI = corXY$CI_TS[2])
  res
  
}

